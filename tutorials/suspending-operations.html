<div class="static-content">

  <div class="index-list">

    <ul>
      <li><a href="#page-suspend-feature">Suspend rendering feature</a></li>
      <li><a href="#page-suspend-api">API methods</a></li>
      <li><a href="#page-suspend-demo">Supsend - an example</a></li>
    </ul>
  </div>

  <div class="example-container head-gap clearfix" name="suspend-feature">
    <h3 id="page-suspend-feature">Suspend rendering feature</h3>
    <p>Suspend/batch operation might be useful if you want to improve the performance.
      Batching several costly operations can decrease the number of reflows and render cycles for CRUD operations.
      It results in less layout trashing, fewer freezes, and a more responsive feel.
      <br>
      This feature enables suspending of rendering, execution or both. Rendering refers to DOM rendering, the term
      execution refers to all operations that are different from DOM rendering. Currently only the indexes recalculation allows to postpone the process.

      <br>
      There are several <strong>API methods</strong> which allow suspending:
    </p>
    <ul>
      <li><code>suspendRender</code> and <code>resumeRender</code> pair</li>
      <li><code>batchRender</code></li>
      <li><code>suspendExecution</code> and <code>resumeExecution</code> pair</li>
      <li><code>batchExecution</code></li>
      <li><code>batch</code></li>
    </ul>
    <p>
      Please note that this is an advanced feature which can improve the performance but should be used with caution.
      Misuse can result in some flickering, glitches, or other visual distortion.
    </p>

  <div class="example-container head-gap clearfix" name="suspend-api">
    <h3 id="page-suspend-api">Suspend API methods</h3>
    <h4>Suspend rendering</h4>

    <p>
      <strong>suspendRender</strong> and <strong>resumeRender</strong>
      <br>
      To suspend the rendering process you can use <code>suspendRender</code> method just before the actions you want to postpone.
      There is a small drawback to this manual approach - you need to remember to resume the process
      with the <code>resumeRender</code> method.
      <pre>
        <code class="lang-js">
hot.suspendRender(); // suspend rendering
hot.alter('insert_row', 5, 45);
hot.setDataAtCell(1, 1, 'x');
hot.resumeRender(); // remember to resume rendering
        </code>
      </pre>

      <p><strong>batchRender</strong> </p>
      Batching the render is less prone to human errors. You don't have to remember about resuming the operations.
      However, there is a drawback: it doesn't support async operations.
      <pre>
        <code class="lang-js">
hot.batchRender(() => {
hot.alter('insert_row', 5, 45);
hot.setDataAtCell(1, 1, 'x');
// The table will be rendered once after executing the callback
});
        </code>
      </pre>
    </p>

    <h4>Suspend execution</h4>

    <p>
      <p><strong>suspendExecution</strong> and <strong>resumeExecution</strong></p>
      To suspend the execution you can use the <code>suspendRender</code> method just before the actions you want to postpone.
      There is a small drawback to this manual approach - you need to remember to actually resume the process
      with the <code>resumeRender</code> method.
      <pre>
        <code class="lang-js">
hot.suspendExecution();
const filters = hot.getPlugin('filters');

filters.addCondition(2, 'contains', ['3']);
filters.filter();
hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
hot.resumeExecution(); // It updates the cache internally
        </code>
      </pre>

      <p><strong>batchExecution</strong> </p>
      Batching the execution is less prone to human errors. You don't have to remember about resuming the operations.
      The drawback is - it doesn't support async operations.
      <pre>
        <code class="lang-js">
hot.batchExecution(() => {
  const filters = hot.getPlugin('filters');

  filters.addCondition(2, 'contains', ['3']);
  filters.filter();
  hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
  // The table cache will be recalculated once after executing the callback
});
        </code>
      </pre>
    </p>

    <h4>Batch render and execution</h4>

    <p>
      This method supsends both rendering and other operations.
      It is universal and especially useful if you want to batch multiple API calls within the application.
      <pre>
        <code class="lang-js">
hot.batch(() => {
  hot.alter('insert_row', 5, 45);
  hot.setDataAtCell(1, 1, 'x');

  const filters = hot.getPlugin('filters');

  filters.addCondition(2, 'contains', ['3']);
  filters.filter();
  hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
  // The table cache will be recalculated and table render will be called once after executing the callback
});
        </code>
      </pre>

    </p>

  <div class="example-container clearfix" name="suspend-demo">
    <h3 id="page-suspend-demo">Live demo of suspend feature</h3>
    <p>The following examples show how much the <code>batch</code> method can decrease render time.
      Both of the examples share the same dataset and operations. The first one prints render time
      without batch, the second uses batch.

    </p>
      <div data-jsfiddle="example1">
        <div id="example1" class="hot"></div>
      </div>

      <div class="codeLayout">
        <div class="buttons">
          <button class="jsFiddleLink" data-runfiddle="example1">
            <i class="fa fa-jsfiddle"></i>
            Edit
          </button>
          <button class="dump" name="dump" data-dump="#example1" data-instance="hot1"
                  title="Print current data source to console">
            <i class="fa fa-terminal"></i>
            Log to console
          </button>
        </div>
        <script data-jsfiddle="example1">
              var now = null;

              function startLog() {
                if (now === null) {
                  now = Date.now();
                }
              }

              function printLog() {
                const elapsedTime = Date.now() - now;

                log.appendChild(document.createElement('br'));
                log.appendChild(document.createTextNode(`It took: ${elapsedTime}ms`));
                now = null;
              }

              startLog();
                hot.alter('insert_row', 1, 2);
                hot.alter('insert_col', 1, 2);
                hot.setDataAtCell(1, 1, 'X');
                hot.setDataAtCell(2, 2, 'Y');
                hot.setDataAtCell(3, 3, 'Z');
                hot.setCellMeta(3, 3, 'className', 'green-bg');
                hot.setCellMeta(3, 4, 'className', 'green-bg');
                hot.setCellMeta(4, 3, 'className', 'green-bg');
                hot.setCellMeta(4, 4, 'className', 'green-bg');
              printLog();
              var hot = new Handsontable(document.getElementById('example1'), {
                data: Handsontable.helper.createSpreadsheetData(1000, 25),
                width: 700,
                height: 300,
                rowHeaders: true,
                colHeaders: true,
              });
          </script>
      </div>

      <p>Batch method used:

      </p>
        <div data-jsfiddle="example2">
          <div id="example2" class="hot"></div>
        </div>

        <div class="codeLayout">
          <div class="buttons">
            <button class="jsFiddleLink" data-runfiddle="example2">
              <i class="fa fa-jsfiddle"></i>
              Edit
            </button>
            <button class="dump" name="dump" data-dump="#example2" data-instance="hot2"
                    title="Print current data source to console">
              <i class="fa fa-terminal"></i>
              Log to console
            </button>
          </div>
          <script data-jsfiddle="example2">
              var now = null;

              function startLog() {
                if (now === null) {
                  now = Date.now();
                }
              }

              function printLog() {
                const elapsedTime = Date.now() - now;

                log.appendChild(document.createElement('br'));
                log.appendChild(document.createTextNode(`It took: ${elapsedTime}ms`));
                now = null;
              }

              startLog();
              hot.batch(() => {
                hot.alter('insert_row', 1, 2);
                hot.alter('insert_col', 1, 2);
                hot.setDataAtCell(1, 1, 'X');
                hot.setDataAtCell(2, 2, 'Y');
                hot.setDataAtCell(3, 3, 'Z');
                hot.setCellMeta(3, 3, 'className', 'green-bg');
                hot.setCellMeta(3, 4, 'className', 'green-bg');
                hot.setCellMeta(4, 3, 'className', 'green-bg');
                hot.setCellMeta(4, 4, 'className', 'green-bg');
              })
              printLog();
              var hot = new Handsontable(document.getElementById('example2'), {
                data: Handsontable.helper.createSpreadsheetData(1000, 25),
                width: 700,
                height: 300,
                rowHeaders: true,
                colHeaders: true,
              });
          </script>
        </div>
  </div>

  <p class="gap-top-xsmall">
    <a href="https://github.com/handsontable/docs/edit/<?js= version ?>/tutorials/cell-types.html" class="edit-doc" target="_blank">
      Edit this page
    </a>
  </p>
</div>
